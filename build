#!/usr/bin/env python3

import os
import subprocess
import shutil
import glob
import fnmatch
import multiprocessing as mp

import argparse

WORK_DIRECTORY = os.getcwd()
QUERY_MODULES_DIRECTORY = f"{WORK_DIRECTORY}/dist"
CPP_DIRECTORY = f"{WORK_DIRECTORY}/cpp"
PY_DIRECTORY = f"{WORK_DIRECTORY}/python"
RS_DIRECTORY = f"{WORK_DIRECTORY}/rust"

shutil.rmtree(QUERY_MODULES_DIRECTORY, ignore_errors=True)
os.makedirs(QUERY_MODULES_DIRECTORY)


def get_arguments():
    parser = argparse.ArgumentParser(description="Log scheduling statistics.")
    parser.add_argument("--path", "-p", default=None)
    args = parser.parse_args()

    return args


def copy_dist(destination_path):
    if destination_path is None:
        return
    shutil.copytree(QUERY_MODULES_DIRECTORY, destination_path, dirs_exist_ok=True)


#################################################
#                Copy Utility                   #
#################################################

def copytree(src, dst, ignore_patterns=[]):
    def _check_ignore(x):
        return any(
            [bool(fnmatch.fnmatch(x, pattern)) for pattern in ignore_patterns]
        )

    def _copytree(rel_path=""):
        curr_dir = os.path.join(src, rel_path)
        for item in os.listdir(curr_dir):
            if _check_ignore(item):
                continue

            abs_item = os.path.join(curr_dir, item)
            rel_item = os.path.join(rel_path, item)

            if os.path.isdir(abs_item):
                _copytree(rel_item)
                continue

            destination = os.path.dirname(
                os.path.join(dst, rel_item)
            )  # Joining the tree-based name

            os.makedirs(destination, exist_ok=True)
            shutil.copy2(abs_item, destination)

    _copytree()


#################################################
#              Load C++ modules                 #
#################################################

# Make build directory
CPP_BUILD_DIRECTORY = f"{CPP_DIRECTORY}/build"
os.makedirs(CPP_BUILD_DIRECTORY, exist_ok=True)

# Start CMake building
os.chdir(CPP_BUILD_DIRECTORY)
subprocess.run(["ls", "-l"])
subprocess.run(["cmake", ".."])
core_count = mp.cpu_count()
subprocess.run(["make", f"-j{core_count}"])

# Transfer files to the query modules directory
so_files = glob.glob("**/*.so", recursive=True)
for file in so_files:
    shutil.copy2(file, QUERY_MODULES_DIRECTORY)

#################################################
#             Load Python modules               #
#################################################

os.chdir(PY_DIRECTORY)
ignore_list = [
    "tests",
    "requirements.txt",
    "pytest.ini",
    "htmlcov",
    "__pycache__",
    ".*",
]

# Copy python repository tree inside dist folder
copytree(PY_DIRECTORY, QUERY_MODULES_DIRECTORY, ignore_list)
os.environ["PYTHONPATH"] = PY_DIRECTORY

#################################################
#              Load Rust modules                #
#################################################

os.chdir(RS_DIRECTORY)
for project in filter(
        lambda f: os.path.isdir(f) and f != "rsmgp-sys",
        os.listdir(RS_DIRECTORY)):
    project_dir = os.path.join(RS_DIRECTORY, project)
    os.chdir(project_dir)
    subprocess.run(["cargo", "build", "--release"])

    release_dir = os.path.join(project_dir, "target", "release")
    os.chdir(release_dir)
    modules = glob.glob("*.so")
    assert len(modules) == 1, f"Bad rust/{project} lib."

    module = modules[0]
    src_file = os.path.join(release_dir, module)
    module = module.lstrip("lib") if module.startswith("lib") else module
    dst_file = os.path.join(QUERY_MODULES_DIRECTORY, module)
    shutil.copy2(src_file, dst_file)

#################################################
#            Optional copy dist folder          #
#################################################

arguments = get_arguments()

if arguments.path is not None:
    print('Copying files from folder {src} to {dst} folder.'.format(src=QUERY_MODULES_DIRECTORY, dst=arguments.path))
    copy_dist(arguments.path)
    print('Copying done!')
